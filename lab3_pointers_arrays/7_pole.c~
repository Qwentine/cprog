//-----------------------------------------------------------------
/*
few words about arrays in C:
___________________________________________________________
1) start with index 0, first member has zero index

2) the size of a static array must be known at compile time

3) array definition:

type name[size];
example:
int my_array[5];

4) in **ANSI C** size is fixed and known at compile time, variable can not be used:

int X;
double pole[X]; //not possible in ANSI C, possible since C99
if supported this is called VLA - Variable Length Arrays and a few rules apply:
VLA:
-can not be global
-can not be used in structures
-sizeof() of VLA is runtime evaluated

5)initialization and accessing static array members:
double array[3]={1.0,5.5,6.5};
array[0]=2.0;

6)!!!!!!Arrays can not be manipulated as a whole block (zeroed, compared, assigned )!!!!!!
you always have to use a per index algorithm for such things

7)arrays and sizeof():
for static arrays sizeof() return !!whole array size!!

napr:

short array[5]
int size=sizeof(array) // size = 5 x sizeof(short) !!!however this does not work for array as function parameter!!! 

8)passing arrays to functions
- array is never passed by value (never copied into functions local copy) not even static one
- always passed by reference which makes sizeof operator unable to determine actual external(to a function) array sizes
	- sizeof() return just size of the pointer not the actual array size inside the function
- array dimensions are not passed as well (not even if array static) 
- dimmensions must be passed as separate parameters
 
9) multidimensional static arrays are arranged as a single block of memory => array[1][0] is the same member as array[0][3] 


*/
//-----------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>


int main(void)
{
//************************************
//Varianty pouziti dvourozmerneho pole
//************************************

/*
Varianta prvni
**staticke dvourozmerne pole**


_____________________________________________________________

Varianta prvni (jeste jednou)
**staticke dvourozmerne pole**

- po radcich jako souvisly blok 
- p1 je sice pointer, ale jeho hodnota nemuze byt behem programu zmenena (zustava do konce programu konstantni)
*/
 int p1[2][3];//prace s takovym polem je celkem standardni, zadne necekane zaludnosti nema
 int i,j,k=0;
 for(i=0;i<2;i++)
  for(j=0;j<3;j++)
     p1[i][j]=k++;//pole naplnime 0-5
 puts("Zacatek vypis(p1)");
 vypis(p1,2);
 puts("konec vypis(p1)");
 // p1 je pointer na dvourozmerne pole integeru s delkou radku 3 
 // p1[i] je pointer na i-tou radku
 // *(p1+i) je totez jako p1[i]
		// cili adresa i-te radky
		// cili pointer na i-tou radku
 // p1[i][j] je prvek s indexem [i][j], je samozrejme typu int

//pro zajimavost
puts("Pro zajimavost:\n");
printf("int zabere v pameti sieof(int)=%d\n",(int)sizeof(int));
printf("p1=    %p adresa zacatku pole, nebo take adresa prvniho radku\n", p1); 
printf("p1+1=  %p adresa druheho radku pole\n", (p1+1));  //vsimejme si pointerove aritmetiky
printf("*p1=   %p stale tataz adresa jako prvni pokus, ale tento krat se chape jako adresa prvniho prvku typu int\n", *p1);  
printf("*p1+1= %p adresa druheho prvku v prvnim radku\n", (*p1+1));
printf("*(*p1+1)= %d druhy prvek prvniho radku (je cislo typu int)\n",(*(*p1+1)));


//vypis_jinak(p1,2,3);//by sice proslo pres prekladac s warningem, ale nebude pracovat spravne proc?
                      // protoze vypis_jinak ocekava jinou datovou strukturu, nez jakou ma pole p1
                      // p1 je dvourozmerne pole o dvou radcich a trech sloupcich

/*
Varianta druha
** jednorozmerne pole dvou pointeru **
(z nich kazdy ukazuje na jednu radku)

jedna se vlastne o jednorozmerne pole o dvou prvcich
temito prvky jsou pointery na jednotlive radky pole
*/
 int *p2[2]; // nyni mame staticke jednorozmerne pole o dvou prvcich
             //prvky jsou typu "pointer na int"
             //muzeme do nich tedy neco ulozit
             //napr hodnoty adres v pameti, ktere vrati malloc pri alokaci
 p2[0] = (int *) malloc(3*sizeof(int)); //spravne bychom meli vzdy kontorlovat uspech alokace!!!... ale zde pro jednoduchost opomeneme
 int* neuzitecny = (int*) malloc(1000); //neuzitecna alokace
                                        // ktera ovsem pravdepodobne zaridi, ze nase dva uzitecne bloky pameti nebudou v pameti za sebou
 p2[1] = (int *) malloc(3*sizeof(int));//v kazdem z nasich prvku je ted platna adresa....
                                       // adresa prvniho intu z nove alokovaneho bloku pameti o delce 3 x int

//nyni lze s polem zase standardne pracovat
  k=0;
  for(i=0;i<2;i++) //pozor takoveto pole uz jednu zaludnost ma:
   for(j=0;j<3;j++) //nase samostatne alokovane bloky pameti nemusi a nejspis ani nebudou lezet v pameti za sebou tak, jak
     p2[i][j]=k++; //jsme byli zvykli u statickeho pole
  // p2[0][3] uz tedy zdaleka neni totez jako p2[1][0] (co platilo u statickeho pole)

// vypis(p2,2); //proslo by s warningem prekladacem, ale nepracovalo by spravne
                //vypis() totiz ocekava pointer na pole tri integeru... a ne dvouprvkove pole pointeru na int 
puts("\n\nZacatek vypis_jinak(p2,2,3)");
vypis_jinak(p2,2,3);//vypis jinak projde v poradku, protoze diky definici dvouprvkoveho pole ukazatelu na integer /int *p2[2]/
                    //  je nyni p2 ukazatel na prvni prvek typu ukazatel na int a tedy ukazatel na ukazatel na int, :) coz vypis_jinak presne ocekava 
 puts("konec vypis_jinak");
puts("\n\nPro zajimavost p2:");
printf("ukazatel na int zabere v pameti sizeof(int*)=%d \n",(int)sizeof(int*));
printf("p2=     %p adresa prvniho ze dvou prvku typu ukazatel na int\n",p2);
printf("p2+1=   %p adresa druheho ze dvou prvku --------||-----------\n",p2+1);
puts("Kam tyto adresy ukazuji?");
printf("*p2=    %p adresa prvniho prvku triprvkoveho pole integeru\n",(void *)*p2);
printf("*(p2+1)=%p prvky nemusi vubec ukazovat na pamet za sebou (i kdyz muzou) v zadnem pripade na to vsak nelze spolehat\n",(void *)*(p2+1));



/******************
Varianta treti
** pointer na pole**
*/
 int (*p3)[3]; //p3 neni zadne pole, ale pouze jeden jediny pointer na pole tri integeru 
		// v pameti zatim p3 zabira tak akorat dost mista pro jeden pointer
 p3 = (int (*)[3]) malloc(2*3*sizeof(int)); // alokujeme souvisly blok sesti integeru, vsimneme si dusledneho pretypovani!!!!
						//pretypovavame na "pointer na 3xint"
 k=0;                                       
// diky vyse uvedene definici p3 s nim nyni muzeme pracovat jako s dvourozmernym polem (navic souvislym)
 for(i=0;i<2;i++)
  for(j=0;j<3;j++)
     p3[i][j]=k++;
    //dobra sprava je, ze prvky jsou v pameti opravdu za sebou,
    // tedy p3[0][3] je totez, jako p3[1][0]
    //z hlediska usporadani v pameti se tedy jedna vlastne o dynamickou obdobu statikeho pole a muzeme na nej s klidem pouzit vypis()
vypis(p3,2);
puts("konec vypisu p3");


/****************
Varianta ctvrta
 pointer na pointer
*/
 int** p4; //p4 je pointer na pointer na typ int
 p4 = (int**) malloc( 2*sizeof(int*)); // p4 nyni ukazuje na prvni prvek dvou-prvkoveho pole pointeru na int
 //muzeme jej tedy zacit pouzivat jako jednorozmerne pole dvou pointeru na int
 p4[0]=(int*) malloc(3*sizeof(int));
 p4[1]=(int*) malloc(3*sizeof(int)); //do obou prvku sme zapsali adresu prvniho prvku triprvkoveho pole int-u ktere jsme alokovali
 //nyni pro p4 plati v zasade totez, jako pro p2
 k=0;
 for(i=0;i<2;i++)
  for(j=0;j<3;j++)
     p4[i][j]=k++;
// vypis(p4,2); plati to co pro p2 ,.... projde prekladacem, ale nepracuje spravne
vypis_jinak(p4,2,3);//projde
puts("konec vypisu p4");

//pro jednoduchost sme odflakli free i kontrolu uspesnosti alokace, ale v ostrem programu bychom si to nedovolili
// o dynamicke alokaci vice priste

}

/*
funkcemi vypis se zatim nezabyvejme
projdeme si pro lepsi pochopeni nejdrive vsechny 4 varianty definice vicerozmerneho pole
*/

/*
funkce vypise pole na obrazovku
vyuziva faktu, ze pole je skutecnym polem (prekladac zna jeho delku radky)
ovsem pocet radku si uz musime predat jako dalsi parametr
*/
void print_array(int array[][3],int dim) //pozor definice void vypis(int pole[2][3]){...} NESTACI,
                                     //prekladc si ji vyslvetli jako "void vypis(int pole[][3])" a ani na to neupozorni!!!
				     //neuvadi se tedy prvni index (ostatni ano)
{ 
 int i,j;
 for (i=0;i<dim;i++)
  for(j=0;j<3;j++)
    {
    printf("%d ",array[i][j]);
    puts("");
    }
}

/*
v druhem pripade funkce dostava pouze obecny "pointer na pointer na int" 
spravne pracovat s timto pointerem jako s dvourozmernym polem umozni az kompletni znalost jeho rozsahu I a J
predana jako dalsi parametry
*/
void vypis_jinak(int **pole,int I,int J)
 {
  int i,j;
 for (i=0;i<I;i++)
  for(j=0;j<J;j++)
    {
    printf("%d ",pole[i][j]);
    puts("");
    }
 }
